import { SIGNATURE } from './constants.js';

let LoaderStatus = /*#__PURE__*/function (LoaderStatus) {
  LoaderStatus[LoaderStatus["INITIALIZED"] = 0] = "INITIALIZED";
  LoaderStatus[LoaderStatus["LOADING"] = 1] = "LOADING";
  LoaderStatus[LoaderStatus["SUCCESS"] = 2] = "SUCCESS";
  LoaderStatus[LoaderStatus["FAILURE"] = 3] = "FAILURE";
  return LoaderStatus;
}({});
const DEFAULT_ID = `${SIGNATURE}_Loader`;

/**
 * Kakao Map Api Loader
 *
 * `new Loader(options).load()` 함수를 이용하여 Api를 비동기적으로 삽입할 수 있습니다.
 *
 * 해당 Loader를 이용시 `react-kakao-maps-sdk` 내부에서 injection 되는 이벤트를 감지하여 kakao map api 로딩 이후에 렌더링을 진행합니다.
 */
class Loader {
  static loadcheckcallbacks = [];
  callbacks = [];
  done = false;
  loading = false;
  errors = [];
  constructor(_ref) {
    let {
      appkey,
      id = DEFAULT_ID,
      libraries = [],
      nonce,
      retries = 3,
      url = "//dapi.kakao.com/v2/maps/sdk.js"
    } = _ref;
    this.id = id;
    this.appkey = appkey;
    this.libraries = libraries;
    this.nonce = nonce;
    this.retries = retries;
    this.url = url;
    if (Loader.instance) {
      if (!Loader.equalOptions(this.options, Loader.instance.options)) {
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);
      }
      return Loader.instance;
    }
    Loader.instance = this;
  }
  get options() {
    return {
      appkey: this.appkey,
      id: this.id,
      libraries: this.libraries,
      nonce: this.nonce,
      retries: this.retries,
      url: this.url
    };
  }
  static isLoaded() {
    return new Promise(resolve => {
      if (!Loader.instance) {
        if (window.kakao && window.kakao.maps) {
          return window.kakao.maps.load(() => {
            resolve(true);
          });
        }
        return Loader.loadcheckcallbacks.push(e => {
          resolve(!e);
        });
      }
      if (Loader.instance.status === LoaderStatus.FAILURE) {
        return resolve(false);
      }
      if (Loader.instance.status === LoaderStatus.SUCCESS) {
        return resolve(true);
      }
      Loader.loadcheckcallbacks.push(e => resolve(!e));
    });
  }
  load() {
    return new Promise((resolve, reject) => {
      this.loadCallback(err => {
        if (!err) {
          resolve(window.kakao);
        } else {
          reject(err.error);
        }
      });
    });
  }
  get status() {
    if (this.onerrorEvent) {
      return LoaderStatus.FAILURE;
    }
    if (this.done) {
      return LoaderStatus.SUCCESS;
    }
    if (this.loading) {
      return LoaderStatus.LOADING;
    }
    return LoaderStatus.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  loadCallback(fn) {
    this.callbacks.push(fn);
    this.execute();
  }
  resetIfRetryingFailed() {
    if (this.failed) {
      this.reset();
    }
  }
  reset() {
    this.deleteScript();
    this.done = false;
    this.loading = false;
    this.errors = [];
    this.onerrorEvent = undefined;
  }
  execute() {
    this.resetIfRetryingFailed();
    if (this.done) {
      this.callback();
    } else {
      if (window.kakao && window.kakao.maps) {
        console.warn("Kakao Maps이 이미 외부 요소에 의해 로딩되어 있습니다." + "설정한 옵션과 일치 하지 않을 수 있으며, 이에 따른 예상치 동작이 발생할 수 있습니다.");
        window.kakao.maps.load(this.callback);
        return;
      }
      if (!this.loading) {
        this.loading = true;
        this.setScript();
      }
    }
  }
  setScript() {
    if (document.getElementById(this.id)) {
      this.callback();
    }
    const url = this.createUrl();
    const script = document.createElement("script");
    script.id = this.id;
    script.type = "text/javascript";
    script.src = url;
    script.onerror = this.loadErrorCallback.bind(this);
    script.onload = this.callback.bind(this);
    script.defer = true;
    script.async = true;
    if (this.nonce) {
      script.nonce = this.nonce;
    }
    document.head.appendChild(script);
  }
  loadErrorCallback(event, source, lineno, colno, error) {
    this.errors.push({
      /* eslint-disable @typescript-eslint/ban-ts-comment */
      event,
      source,
      // @ts-ignore
      lineno,
      // @ts-ignore
      colno,
      error
      /* eslint-enable @typescript-eslint/ban-ts-comment */
    });

    if (this.errors.length <= this.retries) {
      const delay = this.errors.length * 2 ** this.errors.length;
      console.log(`Failed to load Kakao Maps script, retrying in ${delay} ms.`);
      setTimeout(() => {
        this.deleteScript();
        this.setScript();
      }, delay);
    } else {
      this.onerrorEvent = this.errors[this.errors.length - 1];
      this.callback();
    }
  }
  createUrl() {
    let url = this.url;
    url += `?appkey=${this.appkey}`;
    if (this.libraries.length) {
      url += `&libraries=${this.libraries.join(",")}`;
    }
    url += `&autoload=false`;
    return url;
  }
  deleteScript() {
    const script = document.getElementById(this.id);
    if (script) {
      script.remove();
    }
  }
  callback() {
    kakao.maps.load(() => {
      this.done = true;
      this.loading = false;
      this.callbacks.forEach(cb => {
        cb(this.onerrorEvent);
      });
      this.callbacks = [];
      Loader.loadcheckcallbacks.forEach(cb => {
        cb(this.onerrorEvent);
      });
      Loader.loadcheckcallbacks = [];
    });
  }
  static equalOptions(a, b) {
    if (a.appkey !== b.appkey) return false;
    if (a.id !== b.id) return false;
    if (a.libraries.length !== b.libraries.length) return false;
    for (let i = 0; i < a.libraries.length; ++i) {
      if (a.libraries[i] !== b.libraries[i]) return false;
    }
    if (a.nonce !== b.nonce) return false;
    if (a.retries !== b.retries) return false;
    if (a.url !== b.url) return false;
    return true;
  }
}

export { Loader, LoaderStatus };
